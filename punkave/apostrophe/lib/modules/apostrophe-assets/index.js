var path = require('path');
var fs = require('fs');

var _ = require('lodash');
var async = require('async');
// JS minifier and optimizer
var uglifyJs = require('uglify-js');
// LESS CSS compiler
var less = require('less');
var moment = require('moment');
var glob = require('glob');
var bless = require('bless');
var lessMiddleware = require('less-middleware');

module.exports = {

  alias: 'assets',

  afterConstruct: function(self) {
    self.apos.tasks.add('apostrophe', 'generation',
      'Run this task to generate new minified assets and perform other pre-startup\ntasks, then exit. This happens on a normal startup too, but if you are running\nmultiple processes or servers you should avoid race conditions by running\nthis task before starting them all.',
      function(apos, argv, callback) {
      // assets were actually generated by afterInit
      return callback(null);
    });

    self.pushDefaults();

    self.pushConfigured();
  },

  construct: function(self, options) {

    self.minified = {};

    // Default stylesheet requirements
    self.stylesheets = [
      // Must have a jQuery UI theme or acceptable substitute for
      // autocomplete and datepickers to be usable. -Tom
      { name: 'vendor/jquery-ui', when: 'always' }
    ];

    // Default browser side script requirements
    // TODO: lots of override options
    self.scripts = [
      // VENDOR DEPENDENCIES

      // Call setImmediate safely on browser side; much faster
      // than setTimeout(fn, 0)
      { name: 'vendor/setImmediate', when: 'always' },
      // For elegant, cross-browser functional-style programming
      { name: 'vendor/lodash.compat', when: 'always' },
      // For async code without tears
      { name: 'vendor/async', when: 'always' },
      // For everything DOM-related
      { name: 'vendor/jquery', when: 'always' },
      // For parsing query parameters browser-side
      { name: 'vendor/jquery-url-parser', when: 'always' },
      // For blueimp uploader, drag and drop reordering of anything, datepicker
      // & autocomplete
      { name: 'vendor/jquery-ui', when: 'always' },
      // For the RTE
      { name: 'vendor/jquery-hotkeys', when: 'user' },
      // Graceful fallback for older browsers for jquery fileupload
      { name: 'vendor/jquery.iframe-transport', when: 'user' },
      // Spiffy multiple file upload
      { name: 'vendor/jquery.fileupload', when: 'user' },
      // imaging cropping plugin
      { name: 'vendor/jquery.Jcrop.min', when: 'user' },
      // textchange event, detects actual typing activity, not just focus change
      { name: 'vendor/jquery-textchange', when: 'always' },
      // select element enhancement plugin
      { name: 'vendor/selectize', when: 'always' },
      // Set, get and delete cookies in browser-side JavaScript
      { name: 'vendor/jquery.cookie', when: 'always' },
      { name: 'vendor/jquery.findSafe', when: 'user' },
      { name: 'vendor/jquery.onSafe', when: 'user' },
      { name: 'vendor/jquery.alter-class', when: 'user' },
      { name: 'vendor/sluggo', when: 'user' },

      // Scroll things into view, even if they are in a scrolling
      // container which itself needs to be scrolled into view or
      // whatever, it's pretty great:
      //
      // http://erraticdev.blogspot.com/2011/02/jquery-scroll-into-view-plugin-with.html
      //
      // (Note recent comments, it's actively maintained). -Tom
      { name: 'vendor/jquery.scrollintoview', when: 'user' },

      // PUNKAVE-MAINTAINED, GENERAL PURPOSE JQUERY PLUGINS

      { name: 'vendor/jquery.get-outer-html', when: 'always' },
      { name: 'vendor/jquery.find-by-name', when: 'always' },
      { name: 'vendor/jquery.projector', when: 'always' },
      { name: 'vendor/jquery.bottomless', when: 'always' },
      { name: 'vendor/jquery.selective', when: 'always' },
      { name: 'vendor/jquery.images-ready', when: 'always' },
      { name: 'vendor/jquery.radio', when: 'always' },
      { name: 'vendor/jquery.json-call', when: 'always' },

      // PUNKAVE-MAINTAINED POLYFILLS

      { name: 'vendor/setImmediate', when: 'always' },

      // PUNKAVE-MAINTAINED OOP SYSTEM
      { name: 'vendor/moog', when: 'always' },

      // APOSTROPHE CORE JS

      // Viewers for standard content types
      { name: 'always', when: 'always' },
    ];

    // Templates pulled into the page by the aposTemplates() Express local
    // These are typically hidden at first by CSS and cloned as needed by jQuery

    self.templates = [
    ];

    // Full paths to assets as computed by pushAsset
    self.pushed = { stylesheets: [], scripts: [], templates: [] };

    self.assetTypes = {
      script: {
        ext: 'js',
        fs: 'public/js',
        web: 'js',
        key: 'scripts',
        serve: 'web'
      },
      stylesheet: {
        ext: 'css',
        fs: 'public/css',
        web: 'css',
        alternate: 'less',
        key: 'stylesheets',
        serve: 'web'
      },
      template: {
        fs: 'views',
        key: 'templates',
        serve: 'fs',
        ext: 'html'
      }
    };

    self.determineGeneration = function() {

      self.isGenerationTask = (self.apos.argv._[0] === 'apostrophe:generation');

      var generation;

      if (self.isGenerationTask) {
        // Create a new generation identifier. The assets module
        // will use this to create asset files that are distinctly
        // named on a new deployment.
        generation = self.apos.utils.generateId();
        fs.writeFileSync(self.apos.rootDir + '/data/generation', generation);
      }

      if (fs.existsSync(self.apos.rootDir + '/data/generation')) {
        generation = fs.readFileSync(self.apos.rootDir + '/data/generation', 'utf8');
        generation = generation.replace(/[^\d]/g, '');
      }

      if (!generation) {
        // In a dev environment, we can just use the pid
        generation = self.apos.pid;
      }

      self.generation = generation;
    }

    // This method pushes assets to be delivered to the browser
    // on every page load.
    //
    // You should be calling the pushAsset method of your module,
    // not this one. It is part of the implementation of the
    // pushAsset method of apostrophe-module, the base class
    // of all modules.
    //
    // But if you really wanted to, you'd have to do this...
    //
    // self.pushAsset('template', 'foo', {
    //   when: 'always'
    // },
    // {
    //   dirname: '/path/to/module',
    //   name: 'apostrophe-modulename',
    //   data: { passed to template }
    // })
    //
    // Or:
    //
    // self.pushAsset('template', function(req, data) {}, {
    //   when: 'always',
    //   data: { passed to function }
    // })

    // Other types: 'stylesheet', 'script'. Unlike 'template' these
    // may not be generated by a function.

    // Templates not generated by a function are loaded from
    // the module's views/ folder.

    // Stylesheets are loaded from the module's public/css folder.

    // Scripts are loaded from the module's public/js folder.

    // Do not supply the file extension.

    // It is acceptable to push an asset more than once. Only one copy
    // is sent, at the earliest point requested.
    //
    // Returns true if an acceptable source file or function for the asset
    // exists, otherwise false.

    self.push = function(type, name, options, context) {

      options = options || {};

      if (self.tooLateToPushAssets) {
        throw 'It is too late to push assets. Hint: push assets in your module\'s constructor, or in your module\'s modulesReady method. afterInit is too late.';
      }

      var data = options ? options.data : undefined;

      var when = (options ? options.when : undefined) || 'always';

      if (typeof(name) === 'function') {
        self.pushed[self.assetTypes[type].key].push({ call: name, data: data, when: when });
        return true;
      }

      var fileDir = context.dirname + '/' + self.assetTypes[type].fs;
      var webDir = self.apos.prefix + '/modules/' + context.name + '/' + self.assetTypes[type].web;

      var filePath = fileDir + '/' + name;
      if (self.assetTypes[type].ext) {
        filePath += '.' + self.assetTypes[type].ext;
      }
      var webPath = webDir + '/' + name;
      if (self.assetTypes[type].ext) {
        webPath += '.' + self.assetTypes[type].ext;
      }

      var exists = fs.existsSync(filePath);

      if (self.assetTypes[type].alternate && fs.existsSync(filePath.replace(/\.\w+$/, '.' + self.assetTypes[type].alternate))) {
        exists = true;
      } else if (fs.existsSync(filePath)) {
        exists = true;
      }

      if (exists) {
        self.pushed[self.assetTypes[type].key].push({ type: type, file: filePath, web: webPath, data: data, preshrunk: options.preshrunk, when: when, minify: options.minify });
      }
      return exists;
    };

    self.tooLateToPushAssets = false;

    // Purge files from public folder matching the glob pattern
    // `pattern`, excepting those with names containing
    // `exceptSubstring`.

    self.purgeExcept = function(pattern, exceptSubstring) {
      var old = glob.sync(self.apos.rootDir + '/public/' + pattern);
      _.each(old, function(file) {
        if (file.indexOf(exceptSubstring) === -1) {
          try {
            fs.unlinkSync(file);
          } catch (e) {
            // This is nonfatal, probably just a race with
            // another process to remove the same file.
          }
        }
      });
    };

    // Name of both folder and extension in
    // public/ for this type of asset
    self.typeMap = {
      scripts: 'js',
      stylesheets: 'css'
    };

    // Wait until the last possible moment - after all modules
    // have been initialized, *and* notified of each other's
    // initialization - to symlink public/modules subdirectories,
    // build master LESS files, and minify (if desired). This
    // allows other modules to wait until they can talk to
    // each other (modulesReady) before pushing assets.

    self.afterInit = function(callback) {
      if (self.apos.isTask() && !self.isGenerationTask) {
        return setImmediate(callback);
      }

      self.tooLateToPushAssets = true;

      // Create symbolic links in /modules so that our web paths can be
      // served by a static server like nginx

      return async.series([
          self.symlinkModules,
          self.buildLessMasters,
          self.minify,
          self.outputAndBless
        ], function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null);
      });
    };

    self.symlinkModules = function(callback) {
      if (!fs.existsSync(self.apos.rootDir + '/public/modules')) {
        fs.mkdirSync(self.apos.rootDir + '/public/modules');
      }
      if (!self.chains) {
        self.chains = {};
      }
      _.each(self.chains, function(chain, name) {
        var last = chain[chain.length - 1];
        var from = self.apos.rootDir + '/public/modules/' + name;
        var to = last.dirname + '/public';
        if (fs.existsSync(to)) {
          // Always recreate the links so we're not befuddled by links
          // deployed from a dev environment
          try {
            // Check whether there is an existing symbolic link
            // (must use lstat so it doesn't resolve the target instead)
            // and if so, remove it
            var stat = fs.lstatSync(from);
            // Symbolic link exists, remove it so we can replace it with
            // a valid one
            fs.unlinkSync(from);
          } catch (e) {
            // Old symbolic link does not exist, that's fine
          }
          // Pass type option for Windows compatibility, hopefully
          fs.symlinkSync(to, from, 'dir');
        }
      });
      return callback(null);
    };

    self.buildLessMasters = function(callback) {
      self.lessMasters = {};
      // Compile all LESS files as one. This is awesome because it allows
      // mixins to be shared between modules for better code reuse. It also
      // allows you to redefine mixins in a later module; if you do so, they
      // are retroactive to the very first use of the mixin. So apostrophe-ui-2
      // can alter decisions made in the apostrophe module, for instance.
      return self.forAllAssetScenes(function(scene, callback) {
        var base = '/css/master-' + scene + '-';
        self.purgeExcept(base + '*', '-' + self.generation);
        var masterWeb = base + self.generation + '.less';
        var masterFile = self.apos.rootDir + '/public' + masterWeb;
        var stylesheets = self.filterAssets(self.pushed.stylesheets, scene, true);
        // Avoid race conditions, if apostrophe:generation created
        // the file already leave it alone
        if (!fs.existsSync(masterFile)) {
          fs.writeFileSync(masterFile, _.map(stylesheets, function(stylesheet) {
            // Cope with the way we push .css but actually write .less
            // because of the middleware. TODO: think about killing that
            var importName = stylesheet.web.replace('.css', '.less');
            if (!fs.existsSync(self.apos.rootDir + '/public' + importName)) {
              importName = stylesheet.web;
            }
            // For import what we need is a relative path which will work on
            // the filesystem too thanks to the symbolic links for modules
            var relPath = path.relative(path.dirname(masterWeb), importName);
            return '@import \'' + relPath + '\';';
          }).join("\n"));
        }
        self.lessMasters[scene] = {
          // The nature of the LESS middleware is that it expects you to
          // request a CSS file and uses LESS to render it if available
          file: masterFile.replace('.less', '.css'),
          web: masterWeb.replace('.less', '.css')
        };
        return callback(null);
      }, callback);
    };

    self.minify = function(callback) {
      self.minified = {};
      if (!self.options.minify) {
        // Just use the LESS middleware and direct access to JS
        // for dev
        return callback(null);
      }
      var minifiers = {
        stylesheets: self.minifyStylesheet,
        scripts: self.minifyScript
      };
      var needed = false;
      return self.forAllAssetScenes(function(scene, callback) {
        return async.eachSeries([ 'stylesheets', 'scripts' ], function(type, callback) {
          self.purgeExcept('/apos-minified/' + scene + '-*.' + self.typeMap[type], '-' + self.generation);
          var file = self.apos.rootDir + '/public/apos-minified/' + scene + '-' + self.generation + '.' + self.typeMap[type];
          if (fs.existsSync(file)) {
            // Someone has already compiled it for the
            // current deployment's asset generation!
            // No startup delay! Booyeah!
            self.minified[scene] = self.minified[scene] || {};
            self.minified[scene][type] = fs.readFileSync(file, 'utf8');
            return setImmediate(callback);
          }
          if (!needed) {
            needed = true;
            console.log('MINIFYING, this may take a minute...');
          }
          return self.minifySceneAssetType(scene, type, minifiers[type], callback);
        }, callback);
      }, function(err) {
        if (err) {
          return callback(err);
        }
        if (needed) {
          console.log('Minification complete.');
        }
        return callback(null);
      });
    };

    self.outputAndBless = function(callback) {
      _.each(self.minified, function(byType, scene) {
        _.each(byType, function(content, type) {
          if (!self.typeMap[type]) {
            return;
          }
          var dir = self.apos.rootDir + '/public/apos-minified';
          if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir);
          }
          var filename = dir + '/' + scene + '-' + self.generation + '.' + self.typeMap[type];
          // Avoid race conditions - don't try to write the
          // same file again if apostrophe:generation already
          // created it for us
          if (fs.existsSync(filename)) {
            return;
          }
          if ((type === 'stylesheets') && self.options.bless) {
            self.splitWithBless(filename, content);
          } else {
            fs.writeFileSync(filename, content);
          }
        });
      });
      return setImmediate(callback);
    };

    // Iterate over all asset scenes. Right now just anon, user
    self.forAllAssetScenes = function(each, callback) {
      if (!self.options.scenes) {
        self.options.scenes = [ 'anon', 'user' ];
      }
      return async.eachSeries(self.options.scenes, each, callback);
    };

    // Minify assets required for a particular scene and populate
    // self.minified appropriately. Supports dot notation in "scene"
    // for scene upgrades. Implements md5-based caching for the really
    // expensive javascript minification step.

    self.minifySceneAssetType = function(scene, type, minifier, callback) {
      var assets;
      // For stylesheets we should have a master LESS file at this point which
      // imports all the rest, so treat that as our sole stylesheet
      if ((type === 'stylesheets') && self.lessMasters && self.lessMasters[scene]) {
        assets = [ self.lessMasters[scene] ];
      } else {
        assets = self.filterAssets(self.pushed[type], scene, true);
      }
      var key;
      var found = false;
      if (!self.minified) {
        self.minified = {};
      }
      if (!self.minified[scene]) {
        self.minified[scene] = {};
      }
      var cache = self.apos.caches.get('minify');
      return async.series({
        checkCache: function (callback) {
          if (type === 'stylesheets') {
            // For now we must ignore the cache for stylesheets because
            // LESS files may include other files which may have been
            // modified, and we have not accounted for that
            return callback(null);
          }
          return async.map(assets, function(asset, callback) {
            if (!fs.existsSync(asset.file)) {
              // It is not uncommon to push assets that a developer doesn't
              // bother to create in, say, a snippet subclass
              return callback(null, 'empty');
            }
            return self.apos.utils.md5File(asset.file, callback);
          }, function(err, md5s) {
            if (err) {
              return callback(err);
            }
            // So the key's components are in a consistent order
            md5s.sort();
            key = type + ':' + scene + ':' + md5s.join(':');
            // So the key is never too long for mongodb
            key = self.apos.utils.md5(key);
            return cache.get(key, function(err, item) {
              if (err) {
                return callback(err);
              }
              if (item !== undefined) {
                self.minified[scene][type] = item;
                found = true;
              }
              return callback(null);
            });
          });
        },
        compileIfNeeded: function(callback) {
          if (found) {
            return callback(null);
          }
          return async.mapSeries(assets, minifier, function(err, codes) {
            if (err) {
              return callback(err);
            }
            var code = codes.join("\n");
            self.minified[scene][type] = code;
            return cache.set(key, code, callback);
          });
        }
      }, callback);
    };

    self.minifyStylesheet = function(stylesheet, callback) {
      return self.compileStylesheet(stylesheet, function(err, code) {
        if (err) {
          return callback(err);
        }
        if (!self.cleanCss) {
          // CSS minifier https://github.com/GoalSmashers/clean-css
          var CleanCss = require('clean-css');
          self.cleanCss = new CleanCss({});
        }
        var minified = self.cleanCss.minify(code);
        if (minified.warnings.length) {
          console.error(minified.warnings.length);
        }
        if (minified.errors.length) {
          return callback(minified.errors);
        }
        minified = minified.styles;
        return callback(null, minified);
      });
    };

    // Minify a single JavaScript file (via the script.file property)
    self.minifyScript = function(script, callback) {
      // For now we don't actually need async for scripts, but now
      // we have the option of going there
      var exists = fs.existsSync(script.file);
      if (!exists) {
        console.log("Warning: " + script.file + " does not exist");
        return callback(null);
      }
      if (script.preshrunk) {
        return callback(null, fs.readFileSync(script.file, 'utf8'));
      }
      var code = uglifyJs.minify(script.file).code;
      return callback(null, code);
    };

    self.compileStylesheet = function(stylesheet, callback) {
      var result;
      var src = stylesheet.file;

      // Make sure we look first for a LESS source file so we're not
      // just using a (possibly stale) previously compiled version
      var lessPath = src.replace(/\.css$/, '.less');
      var exists = false;
      if (fs.existsSync(lessPath)) {
        src = lessPath;
        exists = true;
      } else if (fs.existsSync(src)) {
        exists = true;
      }

      if (!exists) {
        console.log('WARNING: stylesheet ' + stylesheet.file + ' does not exist');
        return callback(null, '');
      }
      // We run ALL CSS through the LESS compiler, because
      // it fixes relative paths for us so that a combined file
      // will still have valid paths to background images etc.
      return less.render(fs.readFileSync(src, 'utf8'),
      {
        filename: src,
        rootpath: path.dirname(stylesheet.web) + '/',
        // Without this relative import paths are in trouble
        paths: [ path.dirname(src) ],
        // syncImport doesn't seem to work anymore in 1.4, thus
        // we were pushed to write endAssets, although it makes
        // sense anyway
      }, function(err, css) {
        if (err) {
          console.error('LESS CSS ERROR:');
          console.error(err);
        }
        css = css.css;
        if (self.prefix) {
          // Call a method provided by appy to be
          // compatible with what the frontend
          // middleware does
          css = self.options.prefixCssUrls(css);
        }
        return callback(err, css);
      });
    };

    // Part of the implementation of self.afterInit, this method
    // returns only the assets that are suitable for the specified
    // scene (`user` or `anon`). Duplicates are suppressed automatically
    // for anything rendered from a file (we can't do that for things
    // rendered by a function).
    //
    // If minifiable is true you get back the assets that can be minified;
    // if set false you get those that cannot; if it is not specified
    // you get both.

    self.filterAssets = function(assets, when, minifiable) {
      // Support older layouts
      if (!when) {
        throw new Error('You must specify the "when" argument (usually either anon or user)');
      }

      // Always stomp duplicates so that devs don't have to worry about whether
      // someone else pushed the same asset.
      var once = {};
      var results = _.filter(assets, function(asset) {
        if (minifiable !== undefined) {
          if (minifiable === true) {
            if (asset.minify === false) {
              return false;
            }
          }
          if (minifiable === false) {
            if (asset.minify !== false) {
              return false;
            }
          }
        }
        var relevant = (asset.when === 'always') || (when === 'all') || (asset.when === when);
        if (!relevant) {
          return false;
        }
        if (asset.call) {
          // We can't stomp duplicates for templates rendered by functions
          return true;
        }
        var key = asset.name + ':' + asset.fs + ':' + asset.web;
        if (once[key]) {
          return false;
        }
        once[key] = true;
        return true;
      });
      return results;
    };

    // Fetch an asset chain by name. Note that the
    // name of the chain for a project-level override
    // of the "foo" module is "my-foo". Otherwise it
    // is the name of the module.

    self.getChain = function(name) {
      return self.chains[name];
    };

    self.pushDefaults = function() {
      var i;
      _.each(self.stylesheets || [], function(item) {
        self.pushAsset('stylesheet', item.name, item);
      });
      _.each(self.scripts || [], function(item) {
        self.pushAsset('script', item.name, item);
      });
      _.each(self.templates || [], function(item) {
        self.pushAsset('template', item.name, item);
      });
    };

    self.pushConfigured = function() {
      var i;
      _.each(self.options.stylesheets || [], function(item) {
        self.pushAsset('stylesheet', item.name, item);
      });
      _.each(self.options.scripts || [], function(item) {
        self.pushAsset('script', item.name, item);
      });
      _.each(self.options.templates || [], function(item) {
        self.pushAsset('template', item.name, item);
      });
    };

    // turn on CSRF protection
    self.apos.push.browserCall('always', 'apos.csrf()');

    // ensure that all $.ajax and related jquery calls
    // respect Apostrophe's prefix automatically
    self.apos.push.browserCall('always', 'apos.prefixAjax()');

    // Render a template asset (a DOM template), taking the
    // locale into account correctly for i18n

    self.renderTemplateAsset = function(req, asset) {
      if (asset.call) {
        return asset.call(asset.data);
      } else {
        return self.apos.templates.render(path.basename(asset.file), asset.data, [ { dirname: path.dirname(asset.file) } ]);
      }
    };

    // For generating unique keys cheaply
    var ordinal = 0;

    // Return a string that uniquely identifies this asset for purposes of
    // determining whether two scenes both contain it. Not guaranteed to
    // be a particularly short string. Not currently implemented
    // for DOM templates

    self.assetKey = function(asset) {
      if (asset.type === 'template') {
        // Right now we don't try to diff these because of the
        // complexity of taking locales into account and the need
        // to render them as part of computing the key. Extra DOM
        // templates don't cost much. So for now, always return a unique key.
        // This way we wind up sending everything 'user' needs
        // if we are asked for 'anon.user'.
        //
        // To change this we would have to add locales to this picture
        // in a comprehensive way.
        return ordinal++;
      }
      // It's a stylesheet or script. The full path to the file
      // is an acceptable key.
      return asset.file;
    };

    self.splitWithBless = function(filename, content) {
      var output = path.dirname(filename);
      new (bless.Parser)({
        output: output,
        options: {}
      }).parse(content.toString(), function (err, files) {
        if (files.length === 1) {
          // No splitting needed, small enough for <= IE9 already
          if (!fs.existsSync(filename)) {
            fs.writeFileSync(filename, content);
          }
          return;
        }
        var master = '';
        var n = 1;
        _.each(files, function(file) {
          var filePath = addN(filename);
          var basename = path.basename(filename);
          var webPath = addN(basename);
          fs.writeFileSync(filePath, file.content);
          master += '@import url("' + webPath + '");\n';
          n++;
        });
        function addN(filename) {
          return filename.replace(/\.css$/, '-' + n + '.css');
        }
        fs.writeFileSync(filename, master);
      });
    };

    self.determineGeneration();

    // TODO: make sure less-middleware gets updated to
    // use LESS 2.2.x, like our minifier does

    self.apos.app.use(lessMiddleware(self.apos.rootDir + '/public', {
      postprocess: {
        css: function(css) {
          if (!self.apos.prefix) {
            return css;
          }
          css = prefixCssUrls(css);
          return css;
        }
      },

      // If requested, use BLESS to split CSS into multiple files
      // for <=IE9, but only if there's enough to make it necessary
      storeCss: function(pathname, css, req, next) {
        if (!self.options.bless) {
          fs.writeFileSync(pathname, css);
          return next();
        }
        self.splitWithBless(pathname, css);
        return next();
      }
    },
    {
      // parser options
    },
    {
      compress: false
    }));

    var staticDir = self.apos.rootDir + '/public';

    ensure(staticDir);
    ensure(staticDir + '/modules');
    ensure(staticDir + '/css');
    ensure(staticDir + '/js');

    self.apos.app.use(self.apos.express.static(self.apos.rootDir + '/public'));

    self.addHelpers({
      // apos.assets.stylesheets renders markup to load CSS that
      // is needed on any page that will use Apostrophe.
      //
      // `when` can be set to either `user` or `anon` and signifies
      // whether a user is logged in or not; when users are
      // logged in editing-related stylesheets are sent,
      // otherwise not.
      //
      // The `when` parameter is made available to your page templates, so typically you
      // just write this in your base layout template in the head element:
      //
      // `{{ apos.assets.stylesheets(data.when) }}`
      //
      // See `outerLayout.html` in the templates module.

      stylesheets: function(when) {
        if (self.options.minify) {
          return self.apos.templates.safe('<link href="' + self.apos.prefix + '/apos-minified/' + when + '-' + self.generation + '.css" rel="stylesheet" />');
        } else {
          if (self.lessMasters && self.lessMasters[when]) {
            return self.apos.templates.safe('<link href="' + self.apos.prefix + self.lessMasters[when].web + '" rel="stylesheet" />');
          }
          return self.apos.templates.safe(_.map(self.filterAssets(self.pushed['stylesheets'], when), function(stylesheet) {
            return '<link href="' + self.apos.prefix + stylesheet.web + '" rel="stylesheet" />';
          }).join("\n"));
        }
      },

      // apos.assets.scripts renders markup to load JS that
      // is needed on any page that will use Apostrophe.
      //
      // `when` can be set to either `user` or `anon` and signifies
      // whether a user is logged in or not; when users are
      // logged in editing-related scripts are sent,
      // otherwise not.
      //
      // The `when` parameter is made available to your page
      // templates, so typically you just write this in
      // outerLayout.html:
      //
      // `{{ apos.assets.scripts(data.when) }}`
      //
      // See `outerLayout.html` in the templates module.
      //
      // apos.assets.scripts also creates the apos object,
      // with its prefix property, so that beforeCkeditor.js
      // and other third party loaders can see the prefix
      // even before our own javascript is loaded.

      scripts: function(when) {
        var result = '<script>\n' +
          'window.apos = {\n' +
          '  prefix: ' + JSON.stringify(self.apos.prefix) + '\n' +
          '};\n' +
          '</script>\n';
        if (self.options.minify) {
          var unminifiable = self.filterAssets(self.pushed['scripts'], when, false);
          result += scriptTags(unminifiable);
          result += '<script src="' + self.prefix + '/apos-minified/' + when + '-' + self.generation + '.js"></script>\n';
          return self.apos.templates.safe(result);
        } else {
          var scriptsWhen = self.filterAssets(self.pushed['scripts'], when);
          result += scriptTags(scriptsWhen);
          return self.apos.templates.safe(result);
        }

        function scriptTags(scripts) {
          return _.map(scripts, function(script) {
            return '<script src="' + self.apos.prefix + script.web + '"></script>';
          }).join("\n");
        }
      },

      // apos.assets.templates renders templates that are needed
      // on all pages. Examples: slideshowEditor.html,
      // codeEditor.html, etc. These lie dormant in the page
      // until they are needed as prototypes to be cloned by
      // jQuery. `when` can be set to either `user` or `anon`
      // and signifies whether a user is logged in or not; when
      // users are logged in editing-related templates are sent,
      // otherwise not. The `when` parameter is made available to
      // your page templates, so typically you just write this
      // in outerLayout.html at the end of the body:
      //
      // `{{ apos.assets.templates(when) }}`

      templates: function(when) {
        if (!when) {
          when = 'all';
        }
        var templates = self.pushed['templates'];
        templates = self.filterAssets(templates, when);
        return self.apos.templates.safe(_.map(templates, function(template) {
          return self.renderTemplateAsset(template).trim();
        }).join(''));
      }
    });

    function ensure(dir) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir);
      }
    }
  }
};
